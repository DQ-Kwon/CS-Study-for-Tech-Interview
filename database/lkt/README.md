# Database Questions

reference

면접을 위한 cs 전공지식노트

---

### 📔 무결성 (integrity)

- 무결성에 대해 설명해주세요.
  - 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것
  - 개체 무결성: 기본키를 구성하는 모든 속성은 NULL값을 가질 수 없다.
  - 참조 무결성: 외래키는 참조할 수 없는 값을 가질 수 없다.

<br>

- 무결성을 유지하려는 이유가 무엇인가요?
  - 무결성이 유지되어야 DB에 저장된 데이터 값과 해당하는 현실 세계의 값이 일치하는 것에 대해 신뢰할 수 있기 때문이다,.

<br>

---

### 📔 인덱스 (Index)

- DB 인덱스에 대해 설명해주세요.
  - 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

<br>

- DB 인덱스를 사용하는 이유는 무엇인가요?
  - DB에서 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕는다.

<br>

- DB 인덱스에 해쉬 보다 B Tree를 쓰는 이유는 무엇인가요?
  - 해시는 등호(=) 연산에만 특화되어 있고 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하기 때문에 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다. 데이터가 정렬된 상태로 유지되는 B Tree를 사용하면 O(logN)의 빠른 시간으로 검색할 수 있다.

<br>

---

### 📔 관계형 DB vs 비관계형 DB

- 관계형 DB 와 비관계형 DB 의 차이점에 대해 설명해주세요.

  - 관계형 데이터베이스란 테이블로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타낸다. 이처럼 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스의 특징이다. 비 관계형 데이터베이스는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스이다. 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징이다. 데이터를 저장할 때 SQL문이 아닌 다른 프로그래밍 언어 및 구문을 사용한다.

    <br>

- RDBMS과 비교하였을 때 NoSQL의 장점을 설명해보세요.

  - JOIN 처리가 없기 때문에 수평적 확장(더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미)이 용이하다. 가변적인 데이터구조로 데이터를 저장할 수 있어서 훨씬 더 유연성이 높다.

    <br>

- 어떤상황에서 NoSQL을 쓰는 것이 더 적합한가?
  - 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
  - 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
  - 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)

<br>

---

### 📔 트랜잭션 (Transaction)

- 트랜잭션이란?

  - 하나의 논리적 기능을 수행하기 위한 작업의 단위로, DB의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능을 수행한다.

    <br>

- 트랜잭션의 성질 ACID

  - 원자성 automicity
    - 트랜잭션의 연산이 DB에 모두 반영되던지, 전혀 반영이 되지 않던지 둘 중에 하나만 수행해야한다.
  - 일관성 consistency
    - 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 변환되어야 한다.
  - 격리성 isolation
    - 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
  - 지속성 durability

    - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장 나더라도 영구적으로 반영되어야 한다.

      <br>

- 트랜잭션을 병행으로 처리할 때 발생할 수 있는 문제점
  - 갱신 내용 손실: 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우
  - 현황 파악 오류: 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
  - 모순성: 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제
  - 연쇄 복귀: 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백 되면 다른 하나의 트랜잭션마저 롤백이 되는 문제

<br>

- Locking 제어가 일으킬 수 있는 문제점

  - 로킹 기법은 교착 상태(Dead lock)가 발생할 수 있다는 한계가 있다.

  <br>

- 트랜잭션에 의해 발생할 수 있는 데드락에 대해 설명

  - 교착 상태란, 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태를 말한다.
  - Dead-lock 발생 조건으로는
    - 상호 배제(Mutal exclusion): 자원은 한 번에 한 프로세스만 사용 가능함
    - 점유 대기(Hold and Wait): 어떤 프로세스가 최소 하나의 자원을 점유하고 다른 프로세스가 사용하는 자원을 할당받기 위해 대기 하고 있음
    - 비선점(No preemption): 다른 프로세스가 사용중인 자원을 강제로 뺏을 수 없음.
    - 순환 대기(Circular wait): 프로세스 pA가 pB가 사용중인 자원을 할당받기 위해 대기하고 pB는 pA의 자원을 할다받으러 대기중임
  - Dead-lock 해결 방법으로는

    - 예방
      - 자원의 상호 배제 조건 방지: 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다. (추후 동기화 관련 문제 발생 가능)
      - 점유 대기 조건 방지: 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또 다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.
      - 비선점 조건 방지: 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
      - 순환 대기 조건 방지: 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.
      - 이러한 조건을 방지해서 데드락을 예방하는 방법은 시스템의 처리량이나 효율성을 떨어뜨리는 단점이 발생할 수 있습니다.
    - 회피
      - 시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 안정 상태(safe state)에 있다고 말합니다. 회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용하자는 것이 기본 특징입니다. Ex) 은행원 알고리즘
    - 탐지하여 회복
      - 탐지 기법
        - Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색합니다. 이외에도 자원할당 그래프를 통해 탐지하는 방법도 있습니다.
      - 회복 기법
        - 데드락을 탐지 기법을 통해 발견 했다면, 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법을 사용합니다.
          - 단순히 프로세스를 1개 이상 중단시키기
          - 교착 상태에 빠진 모든 프로세스를 중단시키는 방법 : 계속 연산 중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
          - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법: 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
          - 자원 선점하기
          - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법

    <br>

- 트랜잭션 격리 수준의 각 레벨에 대해 간략하게 설명
- COMMIT과 ROLLBACK에 대해 설명해주세요
    <br>

---

### 📔 데이터 모델링

- 다양한 데이터 모델에 대해서 설명해주세요.
- 데이터 모델링의 디자인 스키마에 대해서 설명해주세요.
- 위에서 답변한 스키마 중에서 어떤 것이 더 낫습니까?

<br>

---

### 📔 정규화 (Normalization)

- 정규화란 무엇인지, 필요한 이유와 함께 답변해주세요.
  - 정규화의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는다는 것이다. 중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.

<br>

- 각 정규화 단계에 대해 만족되어야 할 조건을 중심으로 설명해주세요.
  - 제 1정규화란 테이블의 컬럼이 원자값을 갖도록 테이블을 분해하는 것이다.
  - 제 2정규화란 제 1정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다. 완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.
  - 제 3정규화란 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다. 여기서 이행적 종속이라는 것은 A->B, B->C가 성립할 때 A->C가 성립되는 것을 의미한다.

<br>            
    
- 함수적 종속에 대해 설명해주세요.
    - X의 값 각각에 대해 Y의 값이 오직 하나로 결정될 때 Y는 X에 종속 된다고 한다. X를 결정자, Y를 종속자라고 한다. X->Y로 표현한다.

    <br>

- 완전함수적 종속/부분함수적 종속/이행함수적 종속에 대해 설명해주세요.
  - 완전 함수적 종속: 종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우
  - 부분 함수적 종속: 릴레이션에서 기본키가 복합키일 경우 기본키를 구성하는 속성 중 일부에게 종속된 경우
  - 이행 함수적 종속: 릴레이션에서 X, Y, Z 라는 3개의 속성이 있을 때 X->Y, Y->Z란 종속 관계가 있을 경우 X->Z가 성립될 경우

<br>

- 역정규화를 하는 이유는 무엇인가요?
  - 역정규화는 데이터베이스의 비용을 최소화하기 위해 중복을 허용하며 Entity를 다시 통합하거나 분할하여 정규화 과정을 통해 도출된 DB 구조를 재조정하는 과정이다. Join이 너무 많아지는 DB설계와 쿼리는 요청을 처리하는 시간을 증가시키는 문제가 있기 때문에 모든 주요 Entity를 분리하는 것이 좋은 것이 아니라 DB의 전반적인 성능을 향상시킬 수 있는 구조화 과정을 거치는 것이 필요하다.

<br>

---

### 📔 기타

- 데이터베이스 장애에 대해 설명해주세요.
- 데이터베이스 회복 기법에 대해 설명해주세요.
- SQL Injection에 대해 설명해주세요
- HINT(힌트)는 무엇인가요?

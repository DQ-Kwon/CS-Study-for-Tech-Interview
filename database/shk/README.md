# Database Questions

reference

면접을 위한 cs 전공지식노트

[https://cocoon1787.tistory.com/778](https://cocoon1787.tistory.com/778)

[https://rebro.kr/163](https://rebro.kr/163)

[https://velog.io/@wisdom-one/정규화Normalization](https://velog.io/@wisdom-one/%EC%A0%95%EA%B7%9C%ED%99%94Normalization)

[https://newehblog.tistory.com/38](https://newehblog.tistory.com/38)

[https://coding-factory.tistory.com/218](https://coding-factory.tistory.com/218)

---

노션 정리 원본
https://foil-radius-405.notion.site/Database-Questions-1cbcc33bbba644d5b8ecd574039ee04b

---

### 📔 무결성 (integrity)
- 무결성에 대해 설명해주세요.
    - 데이터의 정확성, 일관성, 유효성을 유지한다는 것
        - 정확성: 중복이나 누락이 없는 상태
        - 일관성: 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태
        - 유효성: 요구하는 규격에 맞게 입력되어야만 한다는 것
- 무결성을 유지하려는 이유가 무엇인가요?
    - 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 실제 값이 일치하는 지에 대한 신뢰
    - 데이터 무결성 설계를 하지 않는다면 테이블에 중복된 데이터 존재, 부모와 자식 데이터 간의 논리적 관계 깨짐, 잦은 에러와 재개발 비용 발생 등과 같은 문제가 발생

---

### 📔 인덱스 (Index)

- DB 인덱스에 대해 설명해주세요.
    - 데이터를 빠르게 찾을 수 있는 하나의 장치
    - 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조
- DB 인덱스를 사용하는 이유는 무엇인가요?
    - 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있다.
- DB 인덱스에 해쉬 보다 B Tree를 쓰는 이유는 무엇인가요?
    - B-트리
        
        ![Untitled](Database%20Questions%201cbcc33bbba644d5b8ecd574039ee04b/Untitled.png)
        
        - 트리의 노드가 한 방향으로 쏠리지 않도록 노드 삽입 및 삭제 시 특정 규칙에 맞게 재정렬되어 왼쪽과 오른쪽 자식 양쪽 수의 밸런스를 유지하는 트리
        - 항상 양쪽 자식의 밸런스를 유지하므로, 무조건 O(logN)의 시간 복잡도를 가짐
        - 노드 삽입 및 삭제 시 발생하는 재정렬 작업 때문에 탐색을 제외한 작업에서는 일반 Tree보다 성능이 좋지 않다.
    - 해시 테이블
        
        ![Untitled](Database%20Questions%201cbcc33bbba644d5b8ecd574039ee04b/Untitled%201.png)
        
        - (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조
        - 해시가 등호(=) 연산에만 특화되었기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.
    - B Tree를 쓰는 이유
        - 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.
        - 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다.
        - 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.

---

### 📔 관계형 DB vs 비관계형 DB

- 관계형 DB 와 비관계형 DB 의 차이점에 대해 설명해주세요.
    - 관계형 데이터베이스
        - 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
        - SQL라는 언어를 써서 조작 (MySQL, PostgreSQL, 오라클, SQL Server, MSSQL 등)
        - 트랜잭션(전부 아니면 무): 전체 트랜잭션이 하나의 단위로 기록. 실패 시 전체 롤백
        - 정규화: DB설계 시 중복을 최소화해서 구조화하는 프로세스
    - 비관계형 데이터베이스
        - NoSQL (Not Only SQL)
        - 거대한 Map으로서 key-value 형식을 지원함.
        - 관계형 db와 달리 PK,FK JOIN등 관계를 정의하지 않음.
        - 스키마에 대한 정의가 없다.
- RDBMS과 비교하였을 때 NoSQL의 장점을 설명해보세요.
    - 데이터의 성능이 일반적으로 좋아 정렬, 탐색, 분류가 빠름
    - 신뢰성이 높아 데이터의 무결성을 보장
    - 정규화에 따른 갱신 비용을 최소화
- 어떤상황에서 NoSQL을 쓰는 것이 더 적합한가?
    - 데이터의 구조가 거의 또는 전혀 없는 대용량 데이터 저장
    - 클라우드 컴퓨팅 및 저장공간을 최대한 활용하는 경우
    - 빠르게 서비스를 구축하는 과정에서 데이터 구조를 자주 업데이트를 하는 경우

---

### 📔 트랜잭션 (Transaction)

- 트랜잭션이란?
    - 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
    - 여러 개의 쿼리들을 하나로 묶는 단위
- 트랜잭션의 성질 ACID
    - 원자성 automicity
        - 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
        - 트랜잭션을 커밋했는데 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음 보장
        - 일부 operation만 적용되는 것이 아닌 all or nothing
    - 일관성 consistency
        - 허용된 방식으로만 데이터를 변경하는 것
        - 데이터베이스에 기록된 모든 데이터는 여러가지 조건, 규칙에 따라 유효함을 가져야 한다
    - 격리성 isolation
        - 트랜잭션 수행 시 서로 끼어들지 못하는 것
        - 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 함
        - 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함
            
            순차적으로 하면 쉽겠지만 성능 저하
            
        - 여러 개의 격리 수준으로 나뉘어 격리성 보장
            
            ![Untitled](Database%20Questions%201cbcc33bbba644d5b8ecd574039ee04b/Untitled%202.png)
            
    - 지속성 durability
        - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
        - 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함
        - 체크섬, 저널링, 롤백 등 기능 제공
            - 체크섬: 중복검사의 한 형태, 오류 정정을 통해 송신된 자료의 무결성 보호
            - 저널링: 파일 시스템 또는 데이터 베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅, 트랜잭션 등 변경 사항에 대해 로그를 남김
- 트랜잭션을 병행으로 처리할 때 발생할 수 있는 문제점
    - 갱신 분실 (Lost Update)
        - 같은 데이터에 대해 둘 이상의 트랜잭션이 동시에 갱신할 때, 갱신 결과의 일부가 없어지는 현상
    - 모순성 (Inconsistency)
        - 하나의 트랜잭션이 여러 데이터 갱신 연산을 수행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져옴으로써 데이터의 불일치가 발생하는 것
    - 연쇄 복귀 (Cascading Rollback)
        - 병행 수행되던 둘 이상의 트랜잭션 중 어느 한 트랜잭션에 오류가 발생하여 Rollback 하는 경우 다른 트랜잭션들도 함께 Rollback 되는 현상을 말한다.
    - 비완료 의존성 (uncommitted Dependency)
        - 하나의 트랜잭션 수행이 실패한 후 회복하기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상
- 이를 방지하기 위한 방법
(1) Locking 제어 기법을 사용할 때 Locking 단위를 크게/작게 했을 때의 차이점
(2) Locking 제어가 일으킬 수 있는 문제점
    1. 로킹 (Locking)
        - 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법
        - 상호 배제(Mutual Exclusive) 기능을 제공
        - 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 데이터를 독점적으로 사용 가능
        - 한 번에 로킹 할 수 있는 데이터의 크기를 로킹 단위라고 하며 필드(Field), 레코드(Record), 테이블(Table), 파일(File), 데이터베이스(Database) 모두 로킹 단위가 될 수 있다.
        - **Locking 제어 기법을 사용할 때 Locking 단위를 크게/작게 했을 때의 차이점**
            - 로킹 단위가 클수록 병행 제어가 단순해지고 관리하기가 편하지만 병행성 수준이 낮아진다.
            - 반면 로킹 단위가 작을수록 병행 제어가 복잡해지고 오버헤드가 증가하지만, 병행성 수준이 높아지고 데이터베이스 공유도가 높아진다.
        - **Locking 제어가 일으킬 수 있는 문제점**
            - 하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 오직 읽기(read)만 하는 경우에는 동시에 접근해도 문제가 없기 때문에 이런 경우에 효율적이지 못하다 ⇒ 해결법 : 2단계 로킹 규약
            - 교착 상태(Dead lock)
    2. 2단계 로킹 규약 (Two-Phase Locking, 2PL)
        - 각 트랜잭션의 lock과 unlock 요청을 2단계로 실시하는 방식
        - 단계는 확장 단계(Growing phase)와 축소 단계(shrinking phase)로 나뉜다.
            - 확장 단계(Growing phase) : 새로운 lock 연산만을 수행할 수 있고, unlock 연산은 수행할 수 없는 단계
            - 축소 단계(shrinking phase) : unlock 연산을 수행할 수 있고, lock연산은 수행할 수 없는 단계
        - 직렬성을 보장하는 대표적인 로킹 규약이지만 여전히 lock 연산으로 인한 교착상태를 예방할 수는 없다는 단점
    3. 타임스탬프 순서 (Timestamp ordering) 기법
        - 비직렬 트랜잭션을 타임스탬프 순서에 따라 직렬화 시키는 방법
        - 데이터에 접근하는 시간(Timestamp)을 미리 정해두어 부여된 시간 순서대로 데이터에 접근
        - lock을 사용하지 않고 시간을 나눠 사용하기 때문에 교착 상태(Dead lock)가 발생하지 않는다.
        - Rollback 발생률이 높고 연쇄 복귀를 초래할 수 있는 단점
        - 타임스탬프는 트랜잭션을 유일하게 식별할 수 있는 식별자의 역할을 할 수 있으며 트랜잭션의 시작 시간으로 간주
        - 타임스탬프를 생성하는 방법은 논리적 계수기(Logical Count) 또는 시스템 클럭(System Clock)을 이용
            - 논리적 계수기 : 계수기를 사용하여 트랜잭션이 들어올 때마다 카운터를 하나씩 증가
            - 시스템 클럭 : 시스템의 고유 시계 사용
    4. 낙관적 병행 제어 (Optimistic Concurrency Control)
        - 트랜잭션 수행 동안은 어떠한 검사를 하지 않고, 트랜잭션이 종료된 이후에 일괄적으로 검사하는 방식
        - 수행 도중에는 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신하고, 트랜잭션이 종료되고 난 후에 직렬화를 검증하여 검증되면 데이터베이스에 한 번에 반영하는 방식
        - 병행 수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read-only)인 경우, 트랜잭션 간 충돌률이 매우 낮기 때문에 병행 제어 기법을 사용하지 않고도 대부분 일관성을 유지한다는 점을 이용한 방식
    5. 다중 버전 병행 제어 (Multi-version Concurrency Control)
        - 한 데이터에 대해 여러 버전의 값을 유지하며 관리하는 방식
        - 타임스탬프의 개념을 이용하며, 다중 버전 타임 스탬프 기법이라고도 함
        - 여러 버전의 타임스탬프를 비교하여 스케줄상 직렬 가능성이 보장되는 타임스탬프를 선택
        - 충돌이 발생할 경우 연쇄 복귀가 발생할 수 있는 단점
- 트랜잭션에 의해 발생할 수 있는 데드락에 대해 설명
    - 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태
- 트랜잭션 격리 수준의 각 레벨에 대해 간략하게 설명
    - SERIALIZABLE
        - 트랜잭션을 순차적으로 진행시키는 것
        - 여러 트랜잭션이 동시에 같은 행에 접근 불가
        - 매우 엄격한 수준으로 해당 행에 대해 격리
        - 교착 상태 일어날 확률 가능 많고 가장 성능이 떨어지는 격리 수준
    - REPEATABLE_READ
        - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아줌
        - 새로운 행을 추가하는 것은 막지 않음
        - 이후에 추가된 행이 발견될 수 있음
    - READ_COMMITTED
        - 가장 많이 사용되는 격리 수준
        - MySQL8.0., PostgreSQL, SQL Server, 오라클에서 기본값
        - READ_UNCOMMITTED와 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽기 불가
        - 커밋 완료된 데이터에 대해서만 조회 허용
        - 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정 가능
        - 트랜잭션이 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있음
    - READ_UNCOMMITTED
        - 가장 낮은 격리 수준
        - 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제
        - 가장 빠름
        - 데이터 무결성을 위해 되도록 사용하지 않는 것이 이상적
        - 몇몇 행이 조회되지 않더라도 괜찮은 거대한 양의 데이터를 어림잡아 집계하는 데 사용
- COMMIT과 ROLLBACK에 대해 설명해주세요
    - 커밋
        - 여러 쿼리가 성공적으로 처리되었다고 확장하는 명령어
        - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장
        - 커밋이 수행되었다 = 하나의 트랜잭션이 성공적으로 수행되었다
            
            ![Untitled](Database%20Questions%201cbcc33bbba644d5b8ecd574039ee04b/Untitled%203.png)
            
    - 롤백
        - 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 한다면 롤백
        - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일
            
            ![Untitled](Database%20Questions%201cbcc33bbba644d5b8ecd574039ee04b/Untitled%204.png)
            
    - 커밋과 롤백 덕에 데이터의 무결성이 보장된다
    - 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화 할 수 있다.

---

### 📔 데이터 모델링

- 다양한 데이터 모델에 대해서 설명해주세요.
    - 데이터 모델
        - 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화 하여 체계적으로 표현한 개념적 모형
        - 데이터 모델은 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약조건 등을 기술하기 위한 개념적 도구들의 모임
        - 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 논리적으로 표현하기 위해 사용되는 도구
        - 데이터의 구조(Schema)를 논리적으로 묘사하기 위해 사용되는 지능적 도구이다.
    1. 개념적 데이터 모델
        - 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
        - 개념적 데이터 모델은 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현한다.
        - 개념적 데이터 모델은 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 떄문에 정보 모델이라고도 한다.
    2. 논리적 데이터 모델
        - 논리적 데이터 모델은 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정이다.
        - 논리적 데이터 모델은 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현한다.
        - 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미한다.
        - 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용한다.
        - 논리적 데이터 모델은 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분한다.
        
- 데이터 모델링의 디자인 스키마에 대해서 설명해주세요.
    - 조직의 정보 수집과 관리 시스템을 정의하는 시각적 표현 또는 청사진을 생성하는 프로세스
    - 건축가가 집을 짓기 전에 청사진을 설계하는 것과 같은 방식
    - 비즈니스 이해관계자는 조직을 위한 데이터베이스 솔루션을 엔지니어링하기 전에 데이터 모델을 설계
- 위에서 답변한 스키마 중에서 어떤 것이 더 낫습니까?

⇒ 데이터 모델링과 디자인 스키마의 차이를 잘 모르겠음!!

---

### 📔 정규화 (Normalization)

- 정규화란 무엇인지, 필요한 이유와 함께 답변해주세요.
    - 릴레이션 간 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나 해결하기 위해
    - 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리
- 각 정규화 단계에 대해 만족되어야 할 조건을 중심으로 설명해주세요.
    
    ![Untitled](Database%20Questions%201cbcc33bbba644d5b8ecd574039ee04b/Untitled%205.png)
    
    - 정규화된 정도는 정규형(NF, normal form)으로 표현
        - 기본 정규형 : 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형
        - 고급 정규형 : 제4정규형, 제5정규형
    - 1NF
        - 테이블 내의 속성값은 원자값을 가지고 있어야 한다
        - 각 컬럼이 하나의 속성만을 가져야 한다.
        - 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.
        - 각 컬럼이 유일한(unique) 이름을 가져야 한다.
        - 칼럼의 순서가 상관없어야 한다.
    - 2NF
        - 부분 함수 종속을 제거한다 (완전 함수 종속 관계)
            - 완전 함수 종속 관계 = 기본키의 부분집합이 결정자가 되어선 안 된다는 것
        - 제 1정규형을 만족해야 한다.
        - 모든 컬럼이 부분적 종속이 없어야 한다. = 모든 컬럼이 완전 함수 종속을 만족해야 한다.
            - 부분 함수 종속 = 기본키 중에 특정 컬럼에만 종속되는 것을 말한다.
        
        ![https://velog.velcdn.com/images/wisdom-one/post/287cc94a-aed1-42f2-b9a5-aaa64c62e9be/image.png](https://velog.velcdn.com/images/wisdom-one/post/287cc94a-aed1-42f2-b9a5-aaa64c62e9be/image.png)
        
    - 3NF
        - 이행 함수 종속을 제거
        - 제 2정규형을 만족해야 한다.
        - 기본키를 제외한 속성들 간의 이행 종속성 (Transitive Dependency)이 없어야 한다.
            - `A → B`, `B → C` 일 때 `A → C` 를 만족하면 이행 함수 종속이라고 한다.
                
                ![https://velog.velcdn.com/images/wisdom-one/post/1953d93d-5120-4d71-af80-4bd6b3f350df/image.png](https://velog.velcdn.com/images/wisdom-one/post/1953d93d-5120-4d71-af80-4bd6b3f350df/image.png)
                
                - `ID → 등급`, `등급 → 할인율`, `ID → 할인율` 을 만족한다. 즉 이행 함수 종속이 존재한다.
                - 제 3 정규화를 통해 다음과 같이 분리해야 한다.
                    
                    ![https://velog.velcdn.com/images/wisdom-one/post/7f0bfbd9-46da-429c-bf07-60c66642bd02/image.png](https://velog.velcdn.com/images/wisdom-one/post/7f0bfbd9-46da-429c-bf07-60c66642bd02/image.png)
                    
    - BCNF
        - 결정자가 후보키가 아닌 함수 종속을 제거
        - 제 3정규형을 만족해야 한다.
        - 모든 결정자가 후보키 집합에 속해야 한다.
            
            ![https://velog.velcdn.com/images/wisdom-one/post/668e8b1d-ab8e-4529-9d55-1bf9537ea3c0/image.png](https://velog.velcdn.com/images/wisdom-one/post/668e8b1d-ab8e-4529-9d55-1bf9537ea3c0/image.png)
            
        - 위의 테이블은 (학생번호, 과목)이 기본키로 지도교수를 알 수 있다. 그러나 지도교수를 알면 과목을 알 수 있으므로, 지도교수 → 과목 이 종속적이다.즉, 후보키 집합에 속하지 않은 결정자가 존재하므로 BCNF를 만족하지 않는다.
        - BCNF를 만족하기 위해서는 다음과 같이 분리하면 된다.
            
            ![https://velog.velcdn.com/images/wisdom-one/post/2c54e3d9-a815-4cc8-9f23-68aadbdf9b2c/image.png](https://velog.velcdn.com/images/wisdom-one/post/2c54e3d9-a815-4cc8-9f23-68aadbdf9b2c/image.png)
            
    - 4NF
        - 다치 종속을 제거한다
        - BCNF를 만족해야 한다.
        - 다중값 종속(다치 종속)이 없어야 한다.
            - 같은 테이블 내의 독립적인 두 개 이상의 컬럼이 또 다른 컬럼에 종속되는 것을 말한다.즉, A → B 인 의존성에서 단일 값 A와 다중 값 B가 존재한다면 다치 종속이라고 할 수 있다. 이러한 종속을 A ↠ B 로 표기한다. (다치 종속은 이중 화살표(double arrow) ↠ 로 표기한다.)
            - 다치 종속은 최소 2개의 컬럼이 다른 컬럼에 종속되어야 하기 때문에 최소 3개의 컬럼이 필요하다.
        
        ![https://velog.velcdn.com/images/wisdom-one/post/430da4e4-51fb-4e0e-b31a-4602c094eb74/image.png](https://velog.velcdn.com/images/wisdom-one/post/430da4e4-51fb-4e0e-b31a-4602c094eb74/image.png)
        
        - 위의 테이블은 `Person ↠ Mobile` 과 `Person ↠ Food_Likes` 두 가지 의존성을 가지므로 다치 종속이 존재한다.
        - 제 4정규화를 통해 다음과 같이 분리할 수 있다.
            
            ![https://velog.velcdn.com/images/wisdom-one/post/0215ea08-f2d5-4ecc-ab87-94a27475b384/image.png](https://velog.velcdn.com/images/wisdom-one/post/0215ea08-f2d5-4ecc-ab87-94a27475b384/image.png)
            
    - 5NF
        - 조인 종속을 제거한다
            - 하나의 릴레이션을 여러개의 릴레이션으로 분해하였다가, 다시 조인했을 때 데이터 손실이 없고 필요없는 데이터가 생기는 것을 말한다. 조인 종속성은 다치 종속의 개념을 더 일반화한 것이다.
        - 4NF를 만족해야 한다.
        - 더 이상 비손실 분해를 할 수 없어야 한다.
            
            ![https://velog.velcdn.com/images/wisdom-one/post/fee15ae1-3e08-4fa4-905a-d93707e972fe/image.png](https://velog.velcdn.com/images/wisdom-one/post/fee15ae1-3e08-4fa4-905a-d93707e972fe/image.png)
            
        - 위의 결과를 보면 제 4정규화를 수행하기 전 데이터와 다른 것을 알 수 있다.데이터 손실은 없지만 필요없는 데이터가 추가적으로 생겼으므로 5NF를 만족하지 않는다.
        - 제 5정규화를 통해 다음과 같이 분리할 수 있다.
            
            ![https://velog.velcdn.com/images/wisdom-one/post/8a7c4fd8-b140-4144-b2c2-72cd2cf85955/image.png](https://velog.velcdn.com/images/wisdom-one/post/8a7c4fd8-b140-4144-b2c2-72cd2cf85955/image.png)
            
    
- 함수적 종속에 대해 설명해주세요.
    - 어떤 릴레이션 R이 있을때 X와 Y를 각각 속성의 부분집합이라고 가정해봅니다. 여기서 X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, **Y는 X에 함수적 종속**
    이라고 합니다. 이 경우 **X를 결정자**, **Y를 종속자**라고 합니다. 이를 기호로 표현하면 **X→Y**
    입니다. 이런 함수적 종속관계에는 **완전 함수적 종속**과 **부분 함수적 종속** 및 **이행적 함수 종속**이 있습니다.
- 완전함수적 종속/부분함수적 종속/이행함수적 종속에 대해 설명해주세요.
    - 완전함수적 종속
        - 종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우
    - 부분함수적 종속
        - 릴레이션에서 종속자가이 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 속성 중 일부만 종속되는 경우
    - 이행함수적 종속
        - 릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우 X→Z가 성립될 때
        - 즉, X를 알면 Y를 알고 그를 통해 Z를 알 수 있는 경우
- 역정규화를 하는 이유는 무엇인가요?
    - 개발적 측면에서 성능이나 편의성을 위해서 되돌아가는 작업
    - 데이터베이스의 비용을 최소화하기 위해 중복을 허용하며 Entity를 다시 통합하거나 분할하여 정규화 과정을 통해 도출된 DB 구조를 재조정하는 과정
    - 데이터베이스의 물리적 설계 과정에서 성능을 향상시키기 위해

---

### 📔 기타

- 데이터베이스 장애에 대해 설명해주세요.
    - 장애(Failure)는 시스템이 제대로 동작하지 않는 상태를 말한다.
- 데이터베이스 회복 기법에 대해 설명해주세요.
    - 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구 시키는 것
    - 지연갱신 회복 기법(Deferred Update)
        - 트랜잭션의 부분 완료 상태에선 변경 내용을 로그 파일에만 저장
        - 커밋이 발생하기 전까진 데이터베이스에 기록하지 않음
        - 중간에 장애가 생기더라도 데이터베이스에 기록되지 않았으므로 UNDO가 필요 없음(미실행 된 로그 폐기)
    - 즉시갱신 회복 기법(Immediate Update)
        - 트랜잭션 수행 도중에도 변경 내용을 즉시 데이터베이스에 기록
        - 커밋 발생 이전의 갱신은 원자성이 보장되지 않는 미완료 갱신이므로 장애 발생 시 UNDO 필요
    - 검사점 회복 기법 Checkpoint Recovery
        - 체크포인트(Checkpoint) 회복 기법이라고도 한다.
        - 장애 발생 시 검사점(Checkpoint) 이전에 처리된 트랜잭션은 회복에서 제외하고
        - 검사점 이후에 처리된 트랜잭션은 회복 작업 수행
            - 검사점 이후, 장애 발생 이전에 commit이 완료된 경우 Undo 수행
            - 장애 발생 시점까지 commit되지 못한 경우 Redo 수행
    - 그림자 페이징 회복 기법 Shadow Paging Recovery
        - 트랜잭션이 실행되는 메모리상의 Current Page Table과 하드디스크의 Shadow Page Table 이용
        - 트랜잭션 시작시점에 Current Page Table과 동일한 Shadow Page Table 생성
        - 트랜잭션이 성공적으로 완료될 경우 Shadow Page Table 삭제
        - 트랜잭션이 실패할 경우 Shadow Page Table을 Current Page Table로 함
    - 미디어 회복 기법 Media Recovery
        - 디스크와 같은 비휘발성 저장 장치가 손상되는 장애 발생을 대비한 회복 기법
        - 데이터베이스 내용을 백업, 미러링, RAID등을 통해 별도의 물리적 저장장치에 덤프
        - 미디어 장애 시 가장 최근 덤프로 복구하고 로그 파일을 참조해 덤프 이후의 작업 Redo
        - (Undo는 사용되지 않음)
    - ARIES 회복 기법
        - **REDO 중 Repeating history**: 붕괴가 발생했을 때의 데이터베이스 상태를 복구하기 위하여 붕괴 발생 이전에 수행했던 모든 연산을 다시 한번 수행. 붕괴가 발생했을 때 완료되지 않은 상태였던 (진행 트랜잭션)은 UNDO
        - **UNDO 중 Logging**: UNDO를 할 때에도 로깅을 함으로써 회복을 수행하는 도중에 실패하여 회복을 다시 시작할 때에 이미 완료된 UNDO 연산은 반복하지 않음
- SQL Injection에 대해 설명해주세요
    - 악의적인 사용자가 보안상의 취약점을 이용하여, 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위
- HINT(힌트)는 무엇인가요?
    - SQL 튜닝의 핵심 부분으로 일종의 지시 구문
    - 오라클 Optimizer에게 SQL문 실행을 위한 데이터를 스캐닝하는 경로, 조인 방법 등을 알려주기 위해 SQL사용자가 SQL 구문에 작성하는 것
    - 오라클이 항상 최적의 실행 경로를 만들어 내기는 불가능하기 때문에 ****직접 최적의 실행 경로를 작성해 주는 것

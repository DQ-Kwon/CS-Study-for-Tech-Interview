# CS Study - OS(Operating System)

<!-- prettier-ignore -->
|<- 이전 | 현재 | 다음 ->|
|:---:|:---:|:---:|
|[System Call](./os-system_call.md)|CPU Scheduling|[Sync & Async](./os-sync-async.md)|

<br/>

# 3. CPU 스케줄링

## ❓ 자신이 알고 있는 CPU 스케줄링을 선점형, 비선점형으로 나누어 특징을 설명해주세요.

### 선점형 스케줄링(Preemptive Scheduling)

특정 프로세스가 1개의 CPU를 사용하고 있을 때 다른 프로세스가 CPU를 빼앗을 수 있는 방법

프로세스의 우선순위가 높은 프로세스가 CPU를 먼저 차지하기 쉬워 높은 우선순위의 프로세스들이 급히 실행해야 할 때 유용

잦은 컨텍스트 스위칭으로 많은 오버헤드를 초래함

대화식 시분할 시스템에서 빠른 응답 시간을 유지하는데 요구됨

<br/>

### 선점형 스케줄링 종류

#### 1. SRT(Shortest-Remaining-Time) 스케줄링

SJF스케줄링을 선점형으로 구현한 기법으로, SRTF (Shortest-Remaining-Time-First)라고도 함

현재 CPU를 사용하고 있는 프로세스가 있더라도, 다른 프로세스들이 Ready queue에 도착할 때마다 지금 CPU를 사용하고 있는 프로세스의 잔여 작업시간과 비교

먼저 CPU를 잡았다 하더라도 더 짧은 프로세스가 들어오면 CPU를 빼앗기는 방식으로 더욱 최적의 스케줄링 방법

> #### 문제점 1 - Starvation (기아 현상)
>
> 우선순위가 낮은 프로세스는 영원히 CPU를 잡지 못할 수 있음
>
> #### 문제점 2 - CPU burst
>
> 시간을 미리 알 수 없고, 과거 CPU burst time(사용시간)을 통해 예측만 가능

#### 2. 라운드 로빈 스케줄링 (RR: Round Robin)

CPU 스케줄링에서 현재 가장 많이 사용하는 방법의 근간

각 프로세스는 동일한 크기의 할당 시간인 time quantum을 소유

timer에 할당 시간이 끝나면 timer interrupt에 의해 프로세스는 CPU를 운영체제에게 빼앗기고 Ready queue 맨 뒤에 가서 줄을 서게 됨

- 특징

  - CPU의 독점권을 막음
  - I/O bound job과 CPU bound job을 구분하는 효과를 가짐
  - 짧은 응답 시간을 보장
  - 기다리는 시간이 프로세스가 CPU를 쓰려는 시간과 비례

- 성능

  - 할당 시간이 커질수록 FCFS(= FIFO)에 가까워짐
  - 할당 시간이 작아질수록 context switch(문맥 교환) 오버헤드가 증가  
    => 적절한 할당 시간은 I/O bound job은 한 번에 나갈 수 있고, CPU bound job은 한 번에 나갈 수 없는 시간을 줘야 함

- 장점

  - 일반적으로 SJF보다 평균 turnaround time(소요 시간)이 길지만, response time(응답 시간)이 더 짧음

  - 이것의 장점은 interactive job이 많은 경우 효율적

- 단점

  - 모든 시간이 동일한 job만 있을 때는 비효율적

#### 3. 멀티 레벨 큐 (다단계 큐, Multi-Level Queue : MQ)

CPU는 1개지만 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 방법

Ready Queue를 우선순위에 따라 여러 개로 분할하고, 그룹화된 작업들은 각각의 Ready Queue에 넣어 각각의 큐의 독자적인 스케줄링 알고리즘으로 CPU를 할당받음

> #### 전면 작업(foreground, 전위 큐)
>
> 빠른 응답을 필요로 하는 interactive 작업을 넣고, 주로 라운드 로빈 스케줄링 기법을 사용
>
> #### 후면 작업(background, 후위 큐)
>
> human interaction 없이 일반적으로 CPU를 오래 사용하는 계산 위주의 작업을 넣고, 주로 FCFS 스케줄링 기법을 사용 (문맥교환 속도 때문)

<br/>

- 멀티 레벨 큐 종류

  - 고정 우선순위 방식 (Fixed Priority Scheduling)  
    전위 큐의 프로세스에게 CPU가 우선 할당되고, 전위 큐가 비어 있는 경우에만 후위 큐의 프로세스에게 CPU가 할당, 따라서 후위 큐에 대해 Starvation(기아 현상) 가능성이 있음

  - 타임 슬라이스 방식 (Time Slice)  
    전위 큐에 우선순위를 주지만, 조절해서 우선순위를 주는 방법으로, 각 큐에 CPU time을 적절한 비율로 할당한 뒤 이를 통해 전위 큐에 우선순위를 주면서 후위 큐에 Starvation을 방지함

<br/>

#### 4. 멀티 레벨 피드백 큐 (다단계 피드백 큐, Multi-Level Feedback Queue : MFQ)

앞서 설명한 멀티 레벨 큐와 동일하게 CPU는 1개지만 여러 Ready Queue로 줄 서는 스케줄링 기법이며 프로세스가 다른 큐로 이동이 가능

즉, 우선순위의 변화(재배치)가 가능

구현 방식에 따라 상이하지만 다음같은 특징을 유지

큐를 여러 개 둘 수 있고 각각의 큐에 따라 스케줄링 알고리즘을 정할 수 있음

각각의 프로세스를 상위 큐, 하위 큐로 보내는 기준을 지정할 수 있음

프로세스가 CPU를 사용하려 할 때, 들어갈 큐를 결정하는 기준을 지정 할 수 있음

aging과 같은 방식으로 구현이 가능

<br/>

### 비선점형 스케줄링(Non-preemptive Scheduling)

프로세스가 이미 할당된 CPU를 빼앗을 수 없고, 모든 프로세스들의 요구를 공정하게 처리하는 방법

응답 시간의 예측이 쉽고, 컨텍스트 스위칭 횟수가 적음

CPU 사용 시간이 짧은 작업이 사용 시간이 긴 작업을 기다리는 경우가 발생할 수도 있는 것이 단점

일괄처리(batch processing)에 유리

<br/>

### 비선점형 스케줄링 종류

#### 1. 선입 선출 스케줄링(FCFS: First-Come First-Served)

FIFO(First-In First-Out)라고도 부르며, 먼저 온 프로세스에게 CPU를 주는 방법

프로세스의 도착 순서대로 처리하며 CPU스케줄링에서는 비효율적인 편

ex. 은행에서 고객을 처리하는 순서는 도착순이다.

> #### Convoy effect(호위 효과)
>
> 처리시간이 긴 프로세스가 먼저 도착하게 되면 평균 대기시간이 매우 길어짐
>
> 즉, 처리시간이 짧은 short process가 늦게 오면 long process 때문에 오래 기다리게 된다.

<br/>

#### 2. 최단 작업 우선 스케줄링(SJF: Shortest-Job-First)

CPU burst 시간이 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식

CPU를 잡으면 더 짧은 프로세스가 들어와도 먼저 CPU를 준 프로세스의 CPU burst가 완료될 때까지 CPU를 뺏지 않음 (CPU를 유지)

최소 평균 대기시간을 제공하지만, 빠른 응답 시간을 제공해야 하는 대화식 시분할 시스템에는 부적절

짧은 작업일수록 더 좋은 서비스를 받을 수 있어 오버헤드 측면에서 SJF는 짧은 작업 프로세스에 유리

<br/>

#### 3. 우선순위 스케줄링 (Priority Scheduling)

우선순위가 제일 높은 프로세스에게 CPU를 할당하는 방식

일반적으로 우선순위 값 (priority number)가 작을수록 높은 우선순위를 갖음

SJF는 일종의 우선순위 스케줄링 (Priority Scheduling)이다. (우선순위 = 예상되는 다음 CPU 버스트 시간)

- 종류

  1. nonpreemptive  
     먼저 CPU를 잡으면 더 높은 우선순위를 가진 프로세스가 들어와도 CPU burst가 완료될 때까지 CPU를 빼앗기지 않음

  2. preemptive  
     CPU를 사용 중이라 하더라도 더 높은 우선순위를 가진 프로세스가 들어오면 CPU를 뺏김

  > #### 문제점 - Starvation (기아 현상)
  >
  > 우선순위가 낮은 프로세스는 영원히 CPU를 잡지 못할 수 있음
  >
  > #### 해결 방안 - Aging (노화)
  >
  > 아무리 우선순위가 낮은 프로세스라 하더라도 대기 시간이 오래 지나면 우선순위를 높여주어 영원히 CPU를 기다리는 상황을 방지

<br/>

#### 4. 실시간 스케줄링 (Real-time Scheduling)

다른 스케줄링과 달리, deadline이 이 있어 정해진 시간 안에 반드시 작업이 실행이 되어야 하는 프로세스일 때 사용

빨리 실행되는 것보다 deadline을 지키는 것이 중요할 때 사용

- 종류
  1. 경성 실시간 시스템 (hard real-time system)  
     deadline 안에 반드시 작업이 끝나도록 스케줄링해야 함
  2. 연성 실시간 시스템 (soft real-time system)  
     동영상을 재생할 때 초당 프레임을 읽어오는 상황처럼, deadline 존재하기는 하지만 지키지 못했다고 해서 위험한 상황이 생기지는 않음

일반 프로세스에 비해 높은 우선순위를 높여주어 가능하면 먼저 CPU를 얻도록 정책을 구성해야 함

#### 5. HRN(Highest Response ratio Next)

짧은 작업과 대기 시간이 긴 작업의 우선순위를 높이는 방식

SJF의 단점인 긴 작업과 짧은 작업의 과도한 불평등을 보완하기 위한 기법

한 프로세스가 CPU를 사용하면 작업이 완성될 때까지 실행하며, 대기시간이 고려되어 긴 작업과 짧은 작업 사이의 불평등을 어느 정도 완화

<br/>

## ❓ 1에서 설명한 각 CPU 스케줄링의 단점을 설명해주세요.

<br/>
